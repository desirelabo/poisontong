<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#00050a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>密舌 | Mitsushita</title>

<link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;500;600&display=swap" rel="stylesheet">

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
        }
    }
</script>

<style>
:root {
    --bg-void: #00050a;
    --gold: #eebb66;
    --gold-dim: rgba(238, 187, 102, 0.4);
    --gold-glow: rgba(238, 187, 102, 0.8);
    --white: #f5f5f5;
    --ease-IO: cubic-bezier(0.65, 0, 0.35, 1);
}

* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; margin: 0; padding: 0; outline: none; }

/* GLOBAL LOCK */
body {
    background: var(--bg-void); color: var(--white);
    font-family: 'Shippori Mincho', serif;
    overflow: hidden; width: 100vw; height: 100dvh;
    cursor: default; transition: filter 3s ease;
}
::-webkit-scrollbar { display: none; }

/* --- LAYERS --- */
#bg-geometry {
    position: fixed; inset: -50%; width: 200%; height: 200%;
    background-image: url("data:image/svg+xml,%3Csvg width='120' height='120' viewBox='0 0 120 120' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M60 0 L120 60 L60 120 L0 60 Z' fill='none' stroke='%23eebb66' stroke-width='1.2' opacity='0.5'/%3E%3Ccircle cx='60' cy='60' r='35' fill='none' stroke='%23eebb66' stroke-width='0.8' opacity='0.4'/%3E%3Cpath d='M60 15 L105 60 L60 105 L15 60 Z' fill='none' stroke='%23eebb66' stroke-width='0.6' opacity='0.4'/%3E%3C/svg%3E");
    z-index: 0; pointer-events: none;
    animation: rotate-bg 240s linear infinite;
    opacity: 1; transition: opacity 1.5s;
}
@keyframes rotate-bg { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* Global Overlay: Only used for Palette to dim BG. Hidden for Band screens. */
#bg-overlay {
    position: fixed; inset: 0; z-index: 1; pointer-events: none;
    background: radial-gradient(circle at center, rgba(0,5,10,0.3) 0%, rgba(0,5,10,0.9) 100%);
    opacity: 0; transition: opacity 1.5s ease;
}

#layer-webgl { position: fixed; inset: 0; z-index: 10; pointer-events: none; transition: transform 1.5s var(--ease-IO); }

/* UI CONTAINER: PASS-THROUGH */
#layer-ui { 
    position: fixed; inset: 0; z-index: 100; 
    transition: opacity 1s; pointer-events: none;
}

/* --- SECTIONS --- */
.section {
    display: none; position: absolute; inset: 0;
    flex-direction: column; align-items: center; justify-content: center;
    pointer-events: none; /* Inherit pass-through */
}
.section.active { display: flex; }

/* --- CINEMATIC BAND (Top & Breath) --- */
.cinematic-band {
    width: 100%;
    background: rgba(0, 5, 10, 0.2); /* 20% Black */
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    padding: 60px 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    border-top: 1px solid rgba(238, 187, 102, 0.15);
    border-bottom: 1px solid rgba(238, 187, 102, 0.15);
    box-shadow: 0 0 60px rgba(0,0,0,0.4);
    pointer-events: auto; /* CATCH CLICKS */
}

.title-glyph {
    font-size: 3.5rem; letter-spacing: 0.4em; color: var(--gold);
    margin-bottom: 30px; text-indent: 0.4em; text-align: center;
    filter: drop-shadow(0 0 20px var(--gold-glow));
}

.btn-mitsu, .btn-secondary {
    font-family: 'Shippori Mincho', serif; font-size: 1.05rem; letter-spacing: 0.15em;
    padding: 18px 45px; 
    background: linear-gradient(180deg, rgba(30,30,30,0.9), rgba(10,10,10,0.95));
    color: var(--gold);
    border: 1px solid var(--gold); border-radius: 6px;
    position: relative; cursor: pointer; transition: all 0.3s;
    pointer-events: auto; /* FORCE CLICKABLE */
    width: 280px; max-width: 80vw; text-align: center; margin: 15px auto;
    box-shadow: 0 0 20px rgba(238, 187, 102, 0.2); display: block;
}
.btn-mitsu::after { content: ''; position: absolute; inset: 3px; border: 1px solid rgba(238, 187, 102, 0.3); border-radius: 4px; pointer-events: none; }
.btn-mitsu:active { transform: scale(0.96); background: var(--gold); color: #000; }
.btn-secondary { background: rgba(255,255,255,0.05); border-color: rgba(255,255,255,0.3); color: #ccc; box-shadow: none; }

/* --- PALETTE (Fixed Position) --- */
#sec-palette { justify-content: space-between; padding-bottom: 80px; }
.palette-text-area {
    width: 100%; height: 30vh; display: flex; align-items: center; justify-content: center;
    margin-top: 5vh; pointer-events: none;
}
.instruction {
    font-size: 1.3rem; letter-spacing: 0.25em; text-align: center;
    color: #fff; text-shadow: 0 4px 15px #000; font-weight: 500;
}
.palette-wrapper {
    display: flex; justify-content: center; width: 100%;
    pointer-events: auto; z-index: 200;
}
.palette-grid {
    display: flex; flex-wrap: wrap; justify-content: center; align-content: flex-start;
    width: 260px; max-width: 90vw;
}
/* Cluster Layout */
.mineral-btn {
    width: 68px; height: 68px; margin: -6px 8px; /* Cluster */
    transform: rotate(45deg); 
    border: 1px solid rgba(255,255,255,0.4);
    background: radial-gradient(circle at 50% 50%, var(--gem-light), var(--gem-dark));
    box-shadow: 0 0 15px var(--gem-dark); cursor: pointer; transition: transform 0.2s;
    pointer-events: auto;
}
.mineral-btn:active { transform: rotate(45deg) scale(0.9); }
.mineral-btn.selected { 
    border-color: #fff; transform: rotate(45deg) scale(1.1); 
    background: var(--gem-light); box-shadow: 0 0 40px var(--gem-light); z-index: 10; 
}

/* --- RESULT (Local Scroll) --- */
#sec-result {
    display: none; position: absolute; inset: 0;
    overflow-y: auto; overflow-x: hidden; -webkit-overflow-scrolling: touch;
    align-items: center; justify-content: flex-start;
    padding: 0; pointer-events: auto; scrollbar-width: none;
}
#sec-result.active { display: flex; }

.result-content {
    width: 100%; min-height: 100vh;
    padding: 45vh 20px 300px 20px;
    display: flex; flex-direction: column; align-items: center;
}
.result-card {
    background: rgba(0, 3, 5, 0.85); /* Dark Plate */
    backdrop-filter: blur(12px);
    border: 1px solid rgba(238, 187, 102, 0.15); border-radius: 4px;
    padding: 40px 30px; width: 100%; max-width: 600px;
    display: flex; flex-direction: column; align-items: center;
    opacity: 0; transform: translateY(20px); transition: opacity 1s, transform 1s;
}
.result-card.visible { opacity: 1; transform: translateY(0); }
.diagnosis-text { font-size: 1.1rem; line-height: 2.4; letter-spacing: 0.1em; color: #fff; text-align: left; width: 100%; }

.unseal-wrapper { margin-top: 40px; width: 100%; text-align: center; opacity: 0; transition: opacity 1.0s; }
.unseal-wrapper.visible { opacity: 1; }
.checklist-box { width: 100%; margin-top: 40px; display: none; }
.checklist-box.visible { display: block; }
.task-item {
    display: flex; align-items: flex-start; margin-bottom: 20px;
    opacity: 0; transform: translateY(10px); animation: fade-up 1s forwards;
    cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 4px;
}
@keyframes fade-up { to { opacity: 1; transform: translateY(0); } }
.task-check {
    width: 16px; height: 16px; margin-right: 16px; flex-shrink: 0; margin-top: 6px;
    border: 1px solid var(--gold); transform: rotate(45deg); transition: all 0.3s;
}
.task-item.checked .task-check { background: var(--gold); box-shadow: 0 0 15px var(--gold); }
.task-text { font-size: 1.0rem; line-height: 1.7; color: #ddd; transition: 0.3s; }
.task-item.checked .task-text { color: #777; text-decoration: line-through; text-decoration-color: var(--gold); }
.action-area { width: 100%; margin-top: 40px; opacity: 0; transition: opacity 1s; text-align: center; }
.action-area.visible { opacity: 1; }

/* --- ENDING UI --- */
#ending-scene {
    position: fixed; inset: 0; z-index: 500; background: transparent; 
    display: none; flex-direction: column; justify-content: flex-end; align-items: center;
    padding-bottom: 15vh; pointer-events: auto;
}
#ending-scene.active { display: flex; }
.relic-name { font-size: 1.6rem; letter-spacing: 0.3em; color: var(--gold); text-shadow: 0 0 25px var(--gold); margin-bottom: 10px; text-align: center; }
.relic-count { font-size: 0.9rem; letter-spacing: 0.2em; opacity: 0.8; color: #fff; margin-bottom: 40px; text-align: center;}

/* COUNTER */
#play-counter { position: fixed; top: 24px; right: 24px; display: flex; gap: 12px; z-index: 2000; pointer-events: none; }
</style>
</head>
<body>

<div id="bg-geometry"></div>
<div id="bg-overlay"></div>
<div id="layer-webgl"></div>

<div id="layer-ui">
    <section id="sec-top" class="section active">
        <div class="cinematic-band">
            <h1 class="title-glyph">密舌</h1>
            <p style="font-size:0.95rem; letter-spacing:0.25em; opacity:0.9; text-align:center;">一日一回、スイーツより苦い果実を。</p>
            <button class="btn-mitsu" onclick="Mitsushita.Director.startSequence()">深淵へ進む</button>
        </div>
    </section>

    <section id="sec-breath" class="section">
        <div class="cinematic-band">
            <p style="font-size:1.3rem; letter-spacing:0.4em; opacity:0.9; margin:0;">少し吸ってみる</p>
        </div>
    </section>

    <section id="sec-palette" class="section">
        <div class="palette-text-area">
            <p id="pal-inst" class="instruction">世界と対峙するための<br>「鎧」は何色？</p>
        </div>
        <div class="palette-wrapper">
            <div class="palette-grid" id="pal-grid"></div>
        </div>
    </section>

    <section id="sec-result" class="section">
        <div class="result-content">
            <div class="result-card" id="result-card">
                <div id="out-diag" class="diagnosis-text"></div>
                
                <div id="unseal-area" class="unseal-wrapper">
                    <button class="btn-mitsu" style="margin-top:0;" onclick="Mitsushita.Director.unseal()">▼ 処方箋を紐解く ▼</button>
                </div>
                
                <div id="check-box" class="checklist-box"></div>
                
                <div id="act-area" class="action-area">
                    <button class="btn-mitsu" onclick="Mitsushita.Director.captureRelic()">美しさを記録</button>
                    <button id="btn-retry" class="btn-secondary" onclick="Mitsushita.Director.retry()">もう一回？</button>
                </div>
            </div>
        </div>
    </section>
</div>

<div id="ending-scene">
    <div id="end-name" class="relic-name"></div>
    <div id="end-count" class="relic-count"></div>
    <button class="btn-mitsu" onclick="Mitsushita.Director.captureRelic()">美しさを記録</button>
</div>

<div id="play-counter">
    <div class="gem-slot" id="slot-1"></div><div class="gem-slot" id="slot-2"></div><div class="gem-slot" id="slot-3"></div>
</div>

<script type="module">
import * as THREE from 'three';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

const Mitsushita = {
    Config: {
        minerals: [
            { id: 'GARN', name: 'ガーネット', hex: 0xff0000, css: '#8b0000', light:'#ff4d4d', dark:'#4a0000', type: '熱', adj: '重苦しい', key: '執着' },
            { id: 'MORG', name: 'モルガナイト', hex: 0xffc0cb, css: '#ffb6c1', light:'#fff0f5', dark:'#db7093', type: '熱', adj: '湿った', key: '依存' },
            { id: 'LAPI', name: 'ラピスラズリ', hex: 0x0000ff, css: '#191970', light:'#4169e1', dark:'#000080', type: '冷', adj: '乾いた', key: '孤独' },
            { id: 'AQUA', name: 'アクアマリン', hex: 0x00ffff, css: '#7fffd4', light:'#e0ffff', dark:'#20b2aa', type: '静', adj: '透き通った', key: '空虚' },
            { id: 'MALA', name: 'マラカイト', hex: 0x00ff00, css: '#2e8b57', light:'#90ee90', dark:'#006400', type: '動', adj: '濁った', key: '嫉妬' },
            { id: 'SAGE', name: 'セージ', hex: 0x9acd32, css: '#9acd32', light:'#adff2f', dark:'#556b2f', type: '静', adj: '静かな', key: '停滞' },
            { id: 'CITR', name: 'シトリン', hex: 0xffd700, css: '#ffd700', light:'#ffff00', dark:'#daa520', type: '動', adj: '軽い', key: '虚栄' },
            { id: 'OPAL', name: 'オパール', hex: 0xffffff, css: '#fffff0', light:'#ffffff', dark:'#778899', type: '動', adj: '揺れる', key: '嘘' },
            { id: 'OBSD', name: 'オブシディアン', hex: 0x222222, css: '#111111', light:'#555555', dark:'#000000', type: '冷', adj: '固い', key: '拒絶' },
            { id: 'SMOK', name: 'スモーキー', hex: 0x888888, css: '#696969', light:'#c0c0c0', dark:'#2f4f4f', type: '冷', adj: '澱んだ', key: '麻痺' },
            { id: 'AMET', name: 'アメジスト', hex: 0x800080, css: '#800080', light:'#e6e6fa', dark:'#4b0082', type: '熱', adj: '高い', key: '自尊' },
            { id: 'IOLI', name: 'アイオライト', hex: 0x483d8b, css: '#483d8b', light:'#6a5acd', dark:'#191970', type: '静', adj: '深い', key: '悲嘆' }
        ],
        dailyLimit: 3
    },

    Logic: {
        get(id) { return Mitsushita.Config.minerals.find(m => m.id === id); },
        checkDaily() {
            try {
                const now = new Date();
                const reset = new Date(now); reset.setHours(5, 0, 0, 0);
                if (now < reset) reset.setDate(reset.getDate() - 1);
                const key = 'mitsu_final_master';
                const raw = localStorage.getItem(key);
                let data = raw ? JSON.parse(raw) : { date: "", count: 0, history: [] };
                if (data.date !== reset.toDateString()) {
                    data = { date: reset.toDateString(), count: 0, history: [] };
                    localStorage.setItem(key, JSON.stringify(data));
                }
                return data;
            } catch (e) { return { date: new Date().toDateString(), count: 0, history: [] }; }
        },
        saveHistory(yang, yin) {
            const d = this.checkDaily();
            d.count++;
            d.history.push({ yang: yang.id, yin: yin.id, time: Date.now(), dateStr: new Date().toDateString() });
            localStorage.setItem('mitsu_final_master', JSON.stringify(d));
            return d;
        },
        generate(yangId, yinId) {
            const yang = this.get(yangId.id); const yin = this.get(yinId.id);
            const Y = yang.type; const I = yin.type;
            let diag = "";
            if (yang.id === yin.id) diag = `完璧な${yang.name}の鎧。<br>けれど、その内側も同じ色で塗りつぶされている。<br>それは強さではなく、変わることへの恐れ。`;
            else if (Y === '熱' && I === '冷') diag = `${yang.name}のように熱く語りながら、<br>腹の底では${yin.name}のように冷めきっている。<br>その温度差で、あなたの硝子はもうすぐ割れるわ。`;
            else if (Y === '冷' && I === '熱') diag = `${yang.name}のような冷たい仮面の下で、<br>${yin.name}のような${yin.adj}熱が煮えくり返っている。<br>誰も気づかないと思っているの？`;
            else if (Y === '動' && I === '静') diag = `外側では${yang.name}のように愛想よく振る舞い、<br>内側は${yin.name}のように死んでいる。<br>その笑顔は、誰のため？`;
            else if (Y === '静' && I === '動') diag = `${yang.name}の沈黙を守りながら、<br>内側では${yin.name}のような${yin.key}が暴れている。<br>言わないことは、ないことにはならないのよ。`;
            else diag = `${yang.name}の仮面の下で、<br>${yin.name}のような${yin.adj}${yin.key}が息を潜めている。<br>漏れ出す熱が、あなたの嘘を溶かし始めているわ。`;

            const h = new Date().getHours();
            const isNight = (h >= 19 || h <= 4);
            let tasks = isNight 
                ? ["部屋の照明をすべて消し、暗闇に目を慣らす", "心臓の音を10回、手で触れて数える", "今日ついた嘘を一つだけ思い出す"] 
                : ["鏡に映る自分の目を5秒間、逸らさずに見る", "深く息を吸い、肺が膨らむ感覚を確かめる", "今日一度だけ、誰にも合わせずに歩く"];
            return { d: diag, t: tasks };
        }
    },

    Visuals: {
        scene: null, camera: null, renderer: null,
        shell: null, core: null, innerLight: null, backLight: null, sparkles: null,
        matPool: {}, baseScale: 1.0, isRunning: true, isDiagnosing: false, isBreathing: false,
        targetColor: new THREE.Color(0xffffff), currentColor: new THREE.Color(0xffffff),
        
        async init() {
            try {
                const w = window.innerWidth, h = window.innerHeight;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(35, w / h, 0.1, 100);
                this.camera.position.set(0, 0, 15);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                this.renderer.setSize(w, h);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.getElementById('layer-webgl').appendChild(this.renderer.domElement);

                const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
                pmremGenerator.dispose();

                const spot1 = new THREE.SpotLight(0xffffff, 2.0); spot1.position.set(5, 10, 8); 
                const spot2 = new THREE.SpotLight(0xffffff, 1.0); spot2.position.set(-5, -5, 5);
                this.backLight = new THREE.PointLight(0xffffff, 0.0, 15); this.backLight.position.set(0, 1, -6);
                this.scene.add(new THREE.AmbientLight(0x404040, 1.0), spot1, spot2, this.backLight);
                this.innerLight = new THREE.PointLight(0xffffff, 2.0, 10); 
                
                this.shell = new THREE.Mesh(new THREE.IcosahedronGeometry(2.5, 1)); 
                this.core = new THREE.Mesh(new THREE.IcosahedronGeometry(1.0, 0)); 
                this.core.add(this.innerLight);
                this.scene.add(this.shell, this.core);

                Mitsushita.Config.minerals.forEach(m => {
                    this.matPool['S_'+m.id] = new THREE.MeshPhysicalMaterial({
                        color: m.hex, metalness: 0.8, roughness: 0.2, wireframe: true, 
                        emissive: m.hex, emissiveIntensity: 0.5, transparent: true, opacity: 0.3
                    });
                    this.matPool['C_'+m.id] = new THREE.MeshPhysicalMaterial({
                        color: m.hex, emissive: m.hex, emissiveIntensity: 1.0, 
                        transmission: 0.2, thickness: 2.0, roughness: 0.1, metalness: 0.3, ior: 2.0
                    });
                });

                const defMat = new THREE.MeshPhysicalMaterial({ color: 0x444, wireframe: true, transparent:true, opacity:0.1 });
                this.shell.material = defMat; this.core.material = defMat;

                this.initSparkles();
                this.animate();
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            } catch(e) { console.error("3D Error", e); }
        },

        initSparkles() {
            const count = 400; const geo = new THREE.BufferGeometry(); const pos = new Float32Array(count*3);
            for(let i=0; i<count*3; i++) pos[i] = (Math.random()-0.5)*12;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            this.sparkles = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xffffff, size: 0.04, transparent: true, opacity: 0, blending: THREE.AdditiveBlending}));
            this.scene.add(this.sparkles);
        },
        
        focusMode(mode, mineral) {
            const originalColor = this.currentColor.clone();
            this.currentColor.setHex(0xffffff); setTimeout(() => this.currentColor.copy(originalColor), 150);

            if(mode === 'YANG') {
                this.targetCamZ = 16; this.targetShellOp = 0.8; this.targetCoreOp = 0.1;
                this.shell.material = this.matPool['S_'+mineral.id];
            } else if (mode === 'YIN') {
                this.targetCamZ = 11; this.targetShellOp = 0.05; this.targetCoreOp = 1.0;
                this.core.material = this.matPool['C_'+mineral.id];
                this.targetColor.setHex(mineral.hex);
            }
        },
        
        setLoopState(yangId, yinId) {
            const yang = Mitsushita.Logic.get(yangId); const yin = Mitsushita.Logic.get(yinId);
            this.shell.material = this.matPool['S_'+yang.id];
            this.core.material = this.matPool['C_'+yin.id];
            this.targetColor.setHex(yin.hex);
            this.targetCamZ = 13; this.targetShellOp = 0.3; this.targetCoreOp = 1.0; 
            this.boostLight(true);
        },

        resetFocus() { 
            this.targetCamZ = 15; this.targetShellOp = 0.4; this.targetCoreOp = 1.0;
            this.renderer.toneMappingExposure = 1.0; 
        },
        boostLight(on) { 
            this.lightBoost = on ? 2.5 : 1.0; 
            this.backLight.intensity = on ? 3.0 : 0.0; 
            this.renderer.toneMappingExposure = on ? 2.5 : 1.0; 
        },

        targetCamZ: 15, targetShellOp: 0.4, targetCoreOp: 1.0, lightBoost: 1.0,

        async breathSequence() {
            this.isBreathing = true; 
            return new Promise(resolve => {
                const start = Date.now();
                const anim = () => {
                    if(!this.isBreathing) { resolve(); return; } // KILL SWITCH
                    const p = Math.min((Date.now() - start) / 4000, 1);
                    this.baseScale = 1.0 - Math.pow(p, 4);
                    if (p < 1) requestAnimationFrame(anim); else { this.baseScale = 0; resolve(); }
                }; anim();
            });
        },
        restoreModel() { 
            this.isBreathing = false; 
            this.baseScale = 1.0; 
        },

        move(targetState) {
            const el = document.getElementById('layer-webgl');
            el.style.transition = 'transform 1.5s cubic-bezier(0.65, 0, 0.35, 1)';
            
            const ov = document.getElementById('bg-overlay');
            if(targetState === 'palette') {
                el.style.transform = 'translateY(-25%) scale(0.6)';
                ov.style.opacity = '0.6'; 
            } else if(targetState === 'result') {
                el.style.transform = 'translateY(-15%) scale(1.4)';
                ov.style.opacity = '0.0'; 
            } else {
                el.style.transform = 'none';
                ov.style.opacity = '0.0'; 
            }
        },
        
        teleportReset() {
            const el = document.getElementById('layer-webgl');
            el.style.transition = 'none'; el.style.transform = 'none'; void el.offsetWidth;
            this.resetFocus();
        },

        animate() {
            requestAnimationFrame(() => this.animate());
            const t = Date.now() * 0.001;
            
            if(this.camera) this.camera.position.z += (this.targetCamZ - this.camera.position.z) * 0.05;
            if(this.shell && this.shell.material) this.shell.material.opacity += (this.targetShellOp - this.shell.material.opacity) * 0.05;

            let speed = 1.0; 
            if(this.isDiagnosing) { speed = 8.0; }
            else { speed = 1.0 + (Math.sin(t * 0.8) + Math.sin(t * 2.5) * 0.3) * 0.2; }
            
            const flicker = 1.0 + Math.sin(t*2)*0.3;

            const hsl = {}; this.targetColor.getHSL(hsl);
            this.currentColor.setHSL(hsl.h + (Math.sin(t)*0.02), hsl.s, hsl.l);
            
            if(this.core.material.emissive) {
                this.core.material.emissive.copy(this.currentColor);
                this.core.material.emissiveIntensity = 0.5 + (this.lightBoost * 0.8) + (flicker * 0.2);
            }
            if(this.innerLight) {
                this.innerLight.color.copy(this.currentColor);
                this.innerLight.intensity = (flicker * this.targetCoreOp) * 2.0; 
            }
            if(this.backLight) { this.backLight.color.copy(this.currentColor); }

            this.shell.scale.setScalar(this.baseScale);
            this.core.scale.setScalar(this.baseScale);

            if (this.baseScale > 0.01) {
                this.shell.rotation.y += 0.002 * speed; this.shell.rotation.x = Math.sin(t * 0.2) * 0.05;
                this.core.rotation.y -= 0.004 * speed; this.core.rotation.x = Math.sin(t * 0.5) * 0.1 * speed;
                const breath = 1.0 + Math.sin(t*0.8)*0.03;
                this.core.scale.multiplyScalar(breath);
                this.core.position.y = Math.sin(t * 0.8) * 0.2;
            }
            if(this.sparkles) {
                this.sparkles.rotation.y -= 0.0005 * speed; this.sparkles.material.color.copy(this.currentColor);
            }
            this.renderer.render(this.scene, this.camera);
        }
    },

    Director: {
        state: 'INIT', data: { count: 0, yang: null, yin: null, history: [] },
        
        async init() {
            this.updateCounter();
            Mitsushita.Visuals.init();
        },
        updateCounter() {
            const d = Mitsushita.Logic.checkDaily();
            this.data = d;
            for(let i=1; i<=3; i++) document.getElementById(`slot-${i}`).className = i <= d.count ? 'gem-slot filled' : 'gem-slot';
        },
        switchSection(showId) {
            document.querySelectorAll('.section').forEach(el => {
                el.classList.remove('active');
                if(el.id !== showId) setTimeout(() => { 
                    if(!el.classList.contains('active')) el.style.display = 'none';
                }, 600);
            });
            if(showId) {
                const el = document.getElementById(showId);
                el.style.display = 'flex'; void el.offsetWidth; el.classList.add('active');
            }
        },
        // CLEAN RESET
        resetUI() {
            document.querySelectorAll('.mineral-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById('pal-inst').classList.remove('hidden');
            
            const card = document.getElementById('result-card');
            card.removeAttribute('style'); // Physics reset
            card.classList.remove('visible'); 
            
            const btnArea = document.getElementById('unseal-area');
            btnArea.removeAttribute('style');
            btnArea.classList.remove('visible'); 
            
            document.getElementById('check-box').classList.remove('visible');
            document.getElementById('act-area').classList.remove('visible');
            
            const res = document.getElementById('sec-result');
            if(res) res.scrollTop = 0;
        },
        buildGrid(handler) {
            const grid = document.getElementById('pal-grid');
            grid.innerHTML = '';
            Mitsushita.Config.minerals.forEach(m => {
                const b = document.createElement('div'); b.className = 'mineral-btn';
                b.style.setProperty('--gem-light', m.light); b.style.setProperty('--gem-dark', m.dark);
                b.onclick = (e) => { 
                    e.stopPropagation(); 
                    if(!this.state.startsWith('PALETTE')) return;
                    document.querySelectorAll('.mineral-btn').forEach(btn => btn.classList.remove('selected'));
                    b.classList.add('selected'); 
                    document.getElementById('pal-inst').classList.add('hidden');
                    handler(m); 
                };
                grid.appendChild(b);
            });
        },

        async startSequence() {
            this.resetUI();
            this.switchSection('sec-breath');
            
            Mitsushita.Visuals.breathSequence();
            
            // TIMEOUT SAFETY
            setTimeout(() => {
                this.showPalette(); 
            }, 3500);
        },
        
        showPalette() {
            // Restore Model State
            Mitsushita.Visuals.restoreModel();
            
            this.state = 'PALETTE_YANG';
            document.getElementById('pal-inst').innerHTML = '世界と対峙するための<br>「鎧」は何色？';
            
            this.buildGrid((m) => {
                if(this.state !== 'PALETTE_YANG') return;
                this.data.yang = m; Mitsushita.Visuals.focusMode('YANG', m);
                setTimeout(() => {
                    this.state = 'PALETTE_YIN';
                    document.getElementById('pal-inst').innerHTML = '内側に秘めた<br>「熱」は何色？';
                    document.getElementById('pal-inst').classList.remove('hidden');
                    this.buildGrid((m2) => {
                        if(this.state !== 'PALETTE_YIN') return;
                        this.data.yin = m2; Mitsushita.Visuals.focusMode('YIN', m2);
                        document.documentElement.style.setProperty('--core-color', m2.css);
                        this.startDiagnosis();
                    });
                }, 1500);
            });
            Mitsushita.Visuals.move('palette'); this.switchSection('sec-palette');
        },

        startDiagnosis() {
            this.state = 'DIAGNOSING';
            Mitsushita.Visuals.isDiagnosing = true; 
            Mitsushita.Visuals.resetFocus();
            Mitsushita.Visuals.move('result'); 
            
            document.getElementById('sec-palette').classList.remove('active');
            setTimeout(()=>document.getElementById('sec-palette').style.display='none', 600);

            setTimeout(() => {
                Mitsushita.Visuals.isDiagnosing = false;
                this.showResult();
            }, 3000);
        },

        showResult() {
            this.state = 'RESULT';
            const res = Mitsushita.Logic.generate(this.data.yang, this.data.yin);
            
            let html = res.d;
            Mitsushita.Config.minerals.forEach(m => html = html.replace(new RegExp(m.name,'g'), `<span class="kw-inject" style="color:${m.light}">${m.name}</span>`));
            document.getElementById('out-diag').innerHTML = html;
            
            const checkContainer = document.getElementById('check-box');
            checkContainer.innerHTML = '';
            res.t.forEach((task, i) => {
                const item = document.createElement('div');
                item.className = 'task-item';
                item.style.animationDelay = `${i * 0.3}s`; 
                item.onclick = () => { item.classList.toggle('checked'); if(item.classList.contains('checked') && navigator.vibrate) navigator.vibrate(20); };
                item.innerHTML = `<div class="task-check"></div><div class="task-text">${task}</div>`;
                checkContainer.appendChild(item);
            });

            this.switchSection('sec-result');
            Mitsushita.Visuals.boostLight(true); 

            // Reveal Sequence
            const card = document.getElementById('result-card');
            const unsealWrapper = document.getElementById('unseal-area');
            setTimeout(() => {
                card.classList.add('visible');
                setTimeout(() => unsealWrapper.classList.add('visible'), 500);
            }, 500);

            const d = Mitsushita.Logic.saveHistory(this.data.yang, this.data.yin);
            this.updateCounter();
            
            const retry = document.getElementById('btn-retry');
            if(d.count >= 3) { 
                retry.innerText = "眠りにつく（終了）"; retry.onclick = () => this.startEndingLoop(d.history);
            } else { 
                retry.innerText = "もう一回？"; retry.onclick = () => this.retry(); 
            }
        },

        unseal() {
            const btnArea = document.getElementById('unseal-area');
            btnArea.style.opacity = '0';
            setTimeout(() => {
                btnArea.style.display = 'none'; 
                const cb = document.getElementById('check-box'); cb.classList.add('visible');
                setTimeout(() => document.getElementById('act-area').classList.add('visible'), 1500);
            }, 500);
        },

        captureRelic() {
            const ui = document.getElementById('layer-ui'); ui.style.opacity='0';
            const end = document.getElementById('ending-scene'); end.style.display='none';
            const bg = document.getElementById('bg-geometry'); bg.style.opacity='0';
            
            Mitsushita.Visuals.move('result');

            setTimeout(()=>{
                const canvas = document.querySelector('#layer-webgl canvas');
                Mitsushita.Visuals.scene.background = new THREE.Color(0x00050a);
                Mitsushita.Visuals.renderer.render(Mitsushita.Visuals.scene, Mitsushita.Visuals.camera);
                canvas.toBlob(blob => {
                   const a = document.createElement('a'); a.download = `Relic_${Date.now()}.png`;
                   a.href = URL.createObjectURL(blob); a.click();
                });
                Mitsushita.Visuals.scene.background = null;
                alert("聖遺物が精製されました。");
                ui.style.opacity='1'; end.style.display='flex'; bg.style.opacity='1';
            }, 700);
        },

        retry() {
            this.resetUI();
            this.state = 'INIT';
            Mitsushita.Visuals.teleportReset();
            Mitsushita.Visuals.boostLight(false);
            this.startSequence();
        },
        
        startEndingLoop(history) {
            document.getElementById('layer-ui').style.display = 'none';
            const endScene = document.getElementById('ending-scene');
            endScene.classList.add('active'); 
            
            document.getElementById('bg-geometry').style.opacity = '0.5';
            Mitsushita.Visuals.boostLight(true);

            const todayStr = new Date().toDateString();
            const todayHistory = history.filter(h => h.dateStr === todayStr);
            
            let idx = 0;
            const loop = () => {
                if(todayHistory.length === 0) return;
                if(idx >= todayHistory.length) idx = 0;
                
                const rec = todayHistory[idx];
                Mitsushita.Visuals.setLoopState(rec.yang, rec.yin);
                
                const yang = Mitsushita.Logic.get(rec.yang);
                const yin = Mitsushita.Logic.get(rec.yin);
                
                document.getElementById('end-name').innerText = `${yang.name} と ${yin.name}`;
                document.getElementById('end-count').innerText = `RELIC 0${idx+1}`;
                
                idx++;
                setTimeout(loop, 6000);
            };
            loop();
        }
    }
};

window.Mitsushita = Mitsushita;
window.addEventListener('DOMContentLoaded', () => Mitsushita.Director.init());
</script>
</body>
</html>
